<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on umoci</title>
    <link>https://umo.ci/</link>
    <description>Recent content in Home on umoci</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://umo.ci/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Getting an Image</title>
      <link>https://umo.ci/quick-start/getting-an-image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/quick-start/getting-an-image/</guid>
      <description>For most users, before you can do anything with umoci, you have to first have an OCI image. At the time of writing, there is no standard way of getting an OCI image. Distribution is still an open topic in the specification, and there are very few implementations of a distribution extension to the OCI specification. I&amp;rsquo;ve personally worked on one but there is still a lot of work to go before you can skip this step and get OCI images without the need to convert from other things.</description>
    </item>
    
    <item>
      <title>Workflow Optimisation</title>
      <link>https://umo.ci/advanced/workflow-optimisation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/advanced/workflow-optimisation/</guid>
      <description>One of the first things that a user of umoci may notice is that certain operations can be quite expensive. Notably unpack and repack operations require either scanning through each layer archive of an image, or scanning through the filesystem. Both operations require quite a bit of disk IO, and can take a while. Fedora images are known to be quite large, and can take several seconds to operate on.</description>
    </item>
    
    <item>
      <title>Roadmap</title>
      <link>https://umo.ci/reference/roadmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/reference/roadmap/</guid>
      <description>This document describes an informal roadmap for the future of the umoci project, in both technical and operational aspects. If you feel there is something missing from this document, feel free to contribute.
Improved API Design One of the main goals of umoci is to act as a &amp;ldquo;defacto&amp;rdquo; implementation of the relevant image-spec interfaces. In particular, the oci/cas and oci/casext packages are perfect examples of the style of interface that would be incredibly reusable.</description>
    </item>
    
    <item>
      <title>Architecture</title>
      <link>https://umo.ci/reference/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/reference/architecture/</guid>
      <description>umoci is a fairly simple tool, that takes advantage of a couple of tricks in order to allow for modification of OCI images. This architecture document is fairly high-level and will likely change once some more of the roadmap is implemented. If you feel something is missing from this document, feel free to contribute.
When umoci was first released, I also published a blog post outlying the original architecture (which has remained fairly similar over time).</description>
    </item>
    
    <item>
      <title>Workflow</title>
      <link>https://umo.ci/quick-start/workflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/quick-start/workflow/</guid>
      <description>umoci&amp;rsquo;s workflow is based around an unpack-repack cycle, with some separate configuration steps. Most users are going to be primarily using the unpack and repack subcommands for most uses of umoci.
Unpack Each image consists of a set of layers and a configuration that describes how the image should be used. umoci unpack allows you to take an image and extract its root filesystem and configuration into an runtime bundle. This bundle can be used by an OCI compliant container runtime to spawn a container, but also can be used directly by non-containers (as it is just a directory).</description>
    </item>
    
    <item>
      <title>Security Considerations</title>
      <link>https://umo.ci/reference/security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/reference/security/</guid>
      <description>umoci is entrusted with taking a particular image and expanding it on the filesystem (as well as computing deltas of the expanded filesystem). As a result, umoci must be very careful about filesystem access to avoid vulnerabilities that may impact other components of the system. If you feel something is missing from this document, feel free to contribute.
If you&amp;rsquo;ve found a security flaw in umoci that comes from a security consideration we haven&amp;rsquo;t considered before, please follow our instructions on how to responsibly disclose a security issue.</description>
    </item>
    
    <item>
      <title>Creating an Image</title>
      <link>https://umo.ci/quick-start/creating-an-image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/quick-start/creating-an-image/</guid>
      <description>Creating a new image with umoci is fairly simple, and effectively involves creating an image &amp;ldquo;husk&amp;rdquo; which you can then operate on as though it was a normal image. New images contain no layers, and have a dummy configuration that should be replaced by a user.
If you wish to create a new image layout (which contains nothing except the bare minimum to specify that the image is an OCI image), you can do so with umoci init.</description>
    </item>
    
    <item>
      <title>Garbage Collection</title>
      <link>https://umo.ci/quick-start/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/quick-start/garbage-collection/</guid>
      <description>Every umoci operation that modifies an image will not delete any now-unused blobs in the image (so as to ensure that any other operations that assume those blobs are present will not error out). However, this will result in a large number of useless blobs remaining in the image after operating on an image for a long enough period of time. umoci gc will garbage collect all blobs that are not reachable from any known image tag.</description>
    </item>
    
    <item>
      <title>Rootless Containers</title>
      <link>https://umo.ci/quick-start/rootless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/quick-start/rootless/</guid>
      <description>umoci has first class support for rootless containers, and in particular it supports rootless unpacking. This means that an unprivileged user can unpack and repack and image (which is not traditionally possible for most images), as well as generate a runtime configuration that can be used by runc to start a rootless container.
It should noted that the root filesystem created as an unprivileged user will likely not match the root filesystem that a privileged user would create.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://umo.ci/changelog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/changelog/</guid>
      <description>Change Log All notable changes to this project will be documented in this file.
The format is based on Keep a Changelog and this project adheres to Semantic Versioning.
Unreleased  Suppress repeated xattr warnings on destination filesystems that do not support xattrs.  0.4.5 - 2019-12-04 Added  Expose umoci subcommands as part of the API, so they can be used by other Go projects. openSUSE/umoci#289 Add extensible hooking to the core libraries in umoci, to allow for third-party media-types to be treated just like first-party ones (the key difference is the introspection and parsing logic).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://umo.ci/code-of-conduct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/code-of-conduct/</guid>
      <description>Code of Conduct As umoci is part of the openSUSE project, we adopt the openSUSE Code of Conduct. This is enshrined in the openSUSE Guiding Principles, in particular:
 [We value] respect for other persons and their contributions, for other opinions and beliefs. We listen to arguments and address problems in a constructive and open way. We believe that a diverse community based on mutual respect is the base for a creative and productive environment enabling the project to be truly successful.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://umo.ci/contributing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/contributing/</guid>
      <description>Contribution Guidelines If you&amp;rsquo;re reading this, you&amp;rsquo;re likely interested in contributing to this project. That&amp;rsquo;s great! The intention of this document is to describe the basic requirements and rules-of-thumb for contributions.
Security Issues If you are reporting a security issue, do not create an issue or file a pull request on GitHub. Instead, disclose the issue responsibly by sending an email to mailto:cyphar@cyphar.com. If you feel it is necessary you may also encrypt your email with Pretty Good Privacy (PGP) using the PGP key 6FA1B3E3F9A18CDCBE6A2CF54A7BE7BF70DE9B9F.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://umo.ci/governance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://umo.ci/governance/</guid>
      <description>Governance Model umoci currently operates under a BDFL (Benevolent Dictator for Life) model. All final decisions are made by the project owner (who is currently Aleksa Sarai).
When more maintainers join the project, the governance model will likely change to some kind of consensus model &amp;ndash; but until such a change to the governance model is made (and accepted by the BDFL), the BDFL will remain unchanged.
As an openSUSE project, there is an &amp;ldquo;escape hatch&amp;rdquo; governance in the form of the openSUSE Board.</description>
    </item>
    
  </channel>
</rss>